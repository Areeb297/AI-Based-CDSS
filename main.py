# -*- coding: utf-8 -*-
"""CDSS_REF.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17CXyJMU4DDbLS9gPqLh68UYbm4YxoDH-
"""

import uvicorn
import json
import requests
from fastapi import FastAPI
from pydantic import BaseModel
import re


# Initialize FastAPI app
app = FastAPI()

# Load structured knowledge base
with open("./clean_structured_clinical_kb_updated.json") as f:
    knowledge_base = json.load(f)

# Load references
with open("./references_list_key_brackets_value_plain.json") as f:
    references_dict = json.load(f)
references_text = "\n".join([f"{k} {v}" for k, v in references_dict.items()])

# Define request format
class ClinicalRequest(BaseModel):
    drugs: list
    age: int
    gender: str
    allergies: list = []
    diagnosis: str = ''

def get_matches(data, kb):
    matches = {}
    age_range = f"{(data.age // 10) * 10}-{((data.age // 10) + 1) * 10 - 1}"
    if data.age >= 65:
        age_range = "65-120"
    elif data.age < 13:
        age_range = "0-12"
    for category in kb:
        if category == "Indications":
            matches["Indications"] = []
            for drug in data.drugs:
                dl = drug.lower()
                if dl in kb["Indications"]:
                    text = kb["Indications"][dl]
                    matches["Indications"].append(f"{drug.capitalize()}: {text}")
                else:
                    matches["Indications"].append("None")
            continue
        matches[category] = []
        for key, value in kb[category].items():
            if all(str(item).lower() in key.lower() for item in data.drugs + [data.gender.lower(), age_range]):
                matches[category].append(value)
    return matches

def post_process(output_json):
    for k, v in output_json.items():
        if isinstance(v, list) and not v:
            output_json[k] = ["None"]
    return output_json

def fix_missing_commas(json_str):
    # Insert missing commas between JSON elements if missing
    pattern = r'(\])\s+(")'
    fixed_str = re.sub(pattern, r'\1,\n\2', json_str)
    return fixed_str

def fix_indications_list(raw_json):
    import re
    pattern = r'("Indications": \[\s*)(\"[^\]]+)(\])'
    match = re.search(pattern, raw_json, re.DOTALL)
    if match:
        full_match = match.group(0)
        items_str = match.group(2)
        parts = re.split(r'\",\s*\"', items_str.strip('[]"'))
        fixed_items = ['"' + part.strip('"') + '"' for part in parts]
        fixed_list_str = "[\n    " + ",\n    ".join(fixed_items) + "\n]"
        raw_json = raw_json.replace(full_match, f'"Indications": {fixed_list_str}')
    return raw_json



def robust_json_parse(llm_output):
    import regex as re

    # Remove markdown code block formatting if present
    llm_output = re.sub(r"^```(?:json)?\s*|```$", "", llm_output.strip(), flags=re.MULTILINE)

    # Remove trailing commas before closing braces/brackets
    llm_output = re.sub(r",(\s*[\}\]])", r"\1", llm_output)

    # Remove stray extra closing brackets followed by comma (e.g., "],]" => "]")
    llm_output = re.sub(r"\],\s*\]", "]", llm_output)
    llm_output = re.sub(r"\],\s*\}", "}", llm_output)

    # Fix missing commas between top-level array and next key
    llm_output = fix_missing_commas(llm_output)

    # Replace raw newlines inside JSON string values with spaces to avoid control char errors
    def fix_newlines(m):
        s = m.group(0)
        s = s.replace('\n', ' ').replace('\r', ' ')
        return s
    llm_output = re.sub(r'"(.*?)(?<!\\)"', fix_newlines, llm_output, flags=re.DOTALL)

    # Recursive regex to extract JSON object (requires 'regex' module)
    match = re.search(r"\{(?:[^{}]|(?R))*\}", llm_output, re.DOTALL)
    if match:
        json_str = match.group(0)
        try:
            return json.loads(json_str)
        except Exception as e:
            return {"error": "Failed to parse JSON", "exception": str(e), "raw": json_str}
    return {"error": "No JSON object found in model response", "raw": llm_output}


def filter_references_dict(cited_refs, references_dict):
    filtered = []
    seen = set()
    for ref in cited_refs:
        if ref in references_dict and ref not in seen:
            filtered.append(f"{ref} {references_dict[ref]}")
            seen.add(ref)
    return filtered

@app.post("/clinical-assess")
async def assess_clinical_risk(request: ClinicalRequest):
    structured_data = get_matches(request, knowledge_base)
    prompt = f"""
You are a clinical decision support assistant. Your job is to read the user's input and retrieved medical knowledge, and generate a clean structured JSON summary in the exact format below.

Do not include any explanations. Do not write any text before or after the JSON. Your output must ONLY be a valid JSON object.

Use the diagnosis to infer additional clinical risks, especially if not fully covered by the retrieved knowledge.

For example:
- NSAIDs may worsen hypertension or kidney function.
- Aspirin may increase bleeding risk.
- Always evaluate risks based on patient age, gender, and diagnosis.

If a category has no applicable information, return "None" or "N/A" as a string inside an array.

### IMPORTANT REFERENCE CITATION INSTRUCTIONS:
- For each fact or statement in your output, cite ONLY the reference numbers that exactly appear with that fact in the retrieved knowledge.
- DO NOT invent, add, omit, or guess any references.
- DO NOT reuse reference numbers for facts they are not linked to in the retrieved knowledge.
- Preserve the order of references exactly as shown.
- Your output must strictly follow these rules without exceptions.

### JSON FORMAT RULES:
- Use EXACTLY these JSON keys and spelling (case sensitive):
  "Drug-Drug Interactions",
  "Drug-Allergy",
  "Drug-Disease Contraindications",
  "Ingredient Duplication",
  "Pregnancy Warnings",
  "Lactation Warnings",
  "General Precautions",
  "Therapeutic Class Conflicts",
  "Warning Labels",
  "Indications",
  "References".
- Do NOT add or remove keys.
- Do NOT include extra commas, brackets, or characters.
- The JSON must be strictly valid and parsable by standard JSON parsers.


### Input:
{json.dumps(request.dict(), indent=2)}

### Retrieved Knowledge:
{json.dumps(structured_data, indent=2)}

You are a clinical decision support assistant. Given the following patient information, medication list, and diagnosis, generate a detailed structured JSON summary in the following exact format.

**Format:**
{{
  "Drug-Drug Interactions": ["..."],
  "Drug-Allergy": ["..."],
  "Drug-Disease Contraindications": ["..."],
  "Ingredient Duplication": ["..."],
  "Pregnancy Warnings": ["..."],
  "Lactation Warnings": ["..."],
  "General Precautions": ["..."],
  "Therapeutic Class Conflicts": ["..."],
  "Warning Labels": ["..."],
  "Indications": ["..."],
  "References": ["..."]
}}

### Instructions:
- For every drug-drug interaction, mention each pair and cumulative risks if three or more anticoagulant/antiplatelet drugs are present.
- List each interaction separately, and also provide a statement on overall bleeding/toxicity risk when relevant.

- Provide **references** with each clinical claim (FDA label, UpToDate, peer-reviewed guidelines, etc).
- If a category is not relevant, state "None [12]" (where [12] = best clinical practice/expert consensus).
- Include ALL references associated with each fact, especially in "Indications" and "Therapeutic Class Conflicts".
- Do not omit references to keep the output accurate and traceable.
- Ensure the "References" section contains every cited reference from all output categories.
- For "Pregnancy Warnings" and "Lactation Warnings", respond "None (not applicable in male patients). [Best clinical practice]" if the patient is male.

- Output only a valid JSON object. No explanations, no extra text.
- Do NOT include extra commas, brackets, or characters in the JSON.
- Ensure proper JSON formatting, including commas between list and object items.
- The JSON must be strictly valid and parsable by standard JSON parsers.
- Use the exact JSON keys specified; do not add or remove keys.
- Ensure commas separate all JSON items properly.
- Do not add extra spaces or characters inside or outside JSON keys or values.
- The JSON must parse without errors using standard JSON parsers.

- Output only valid JSON with no syntax errors.
- Include commas between list items and between object properties.
- Do NOT omit commas or add extra commas.
- Use the exact JSON keys specified, no misspellings.
- Do not truncate the output.
- References must be complete and consistent.


### Example Input:
{{
  "drugs": [
    "warfarin",
    "amiodarone",
    "simvastatin",
    "metoprolol",
    "clarithromycin"
  ],
  "age": 68,
  "gender": "Male",
  "allergies": [],
  "diagnosis": "Atrial Fibrillation, Hyperlipidemia, Chronic Bronchitis"
}}

### Example Output:
{{
  "Drug-Drug Interactions": [
    "Warfarin and amiodarone: Amiodarone inhibits warfarin metabolism, greatly increasing bleeding risk. [1][2]",
    "Warfarin and clarithromycin: Clarithromycin inhibits warfarin metabolism, increasing INR and bleeding risk. [3][4]",
    "Warfarin and simvastatin: Simvastatin may increase warfarin effect and bleeding risk. [2][5]",
    "Warfarin and metoprolol: No clinically significant interaction. [6]",
    "Amiodarone and simvastatin: Increased risk of statin toxicity (myopathy/rhabdomyolysis). [2][5][7]",
    "Amiodarone and clarithromycin: Increased risk of QT prolongation, arrhythmia. [8][9]",
    "Simvastatin and clarithromycin: Increased risk of statin toxicity due to CYP3A4 inhibition. [2][5][10]",
    "Clarithromycin and metoprolol: Increased metoprolol exposure and risk of bradycardia. [11]",
    "Clarithromycin and amiodarone: Increased risk of QT prolongation and arrhythmia. [8][9]",
    "Overall risk of bleeding and toxicity is high with this drug combination. [1][2][3][4][5][7][8][10][11]"
  ],
  "Drug-Allergy": [ "No allergy conflicts reported. [12]" ],
  "Drug-Disease Contraindications": [
    "Amiodarone: Use with caution in patients with pulmonary disease (risk of pulmonary toxicity). [13]",
    "Clarithromycin: Use with caution in patients with chronic bronchitis/COPD (risk of arrhythmia, drug interactions). [9]"
  ],
  "Ingredient Duplication": [ "None [12]" ],
  "Pregnancy Warnings": [ "None (not applicable in male patients). [Best clinical practice]" ],
  "Lactation Warnings": [ "None (not applicable in male patients). [Best clinical practice]" ],
  "General Precautions": [
    "Monitor INR and signs of bleeding (warfarin). [1][2][3][4][5]",
    "Monitor for myopathy or rhabdomyolysis (simvastatin + amiodarone/clarithromycin). [5][7][10]",
    "Monitor for arrhythmia and bradycardia (amiodarone + clarithromycin + metoprolol). [8][9][11]",
    "Monitor for signs of pulmonary toxicity (amiodarone). [13]"
  ],
  "Therapeutic Class Conflicts": [
    "Multiple CYP inhibitors (amiodarone, clarithromycin) with CYP-metabolized drugs (warfarin, simvastatin, metoprolol): increased toxicity risk. [2][5][8][11]"
  ],
  "Warning Labels": [
    "Black box warning: risk of fatal bleeding with warfarin, especially with inhibitors like amiodarone or clarithromycin. [1][2][3][4]",
    "Statin-associated myopathy risk increases with amiodarone/clarithromycin. [5][7][10]",
    "QT prolongation and arrhythmia risk with amiodarone + clarithromycin. [8][9]"
  ],
  "Indications": [
    "Warfarin: Prevention and treatment of thromboembolic disorders (AFib, DVT, PE). [1]",
    "Amiodarone: Antiarrhythmic for AFib and ventricular arrhythmias. [2]",
    "Simvastatin: Statin for hyperlipidemia. [5]",
    "Metoprolol: Beta blocker for hypertension, angina, AFib. [6]",
    "Clarithromycin: Macrolide antibiotic for respiratory infections. [9]"
  ],

  "References": [
    "[1] FDA label for warfarin: https://www.accessdata.fda.gov/drugsatfda_docs/label/2017/009218s109lbl.pdf",
    "[2] FDA label for amiodarone: https://www.accessdata.fda.gov/drugsatfda_docs/label/2017/018972s046lbl.pdf",
    "[3] FDA label for clarithromycin: https://www.accessdata.fda.gov/drugsatfda_docs/label/2017/050662s049lbl.pdf",
    "[4] UpToDate: Warfarin drug interactions.",
    "[5] FDA label for simvastatin: https://www.accessdata.fda.gov/drugsatfda_docs/label/2016/020702s045lbl.pdf",
    "[6] FDA label for metoprolol: https://www.accessdata.fda.gov/drugsatfda_docs/label/2017/019692s034lbl.pdf",
    "[7] UpToDate: Drug interactions with statins.",
    "[8] FDA label for amiodarone (QT warning).",
    "[9] UpToDate: Macrolide antibiotic drug interactions.",
    "[10] FDA label for simvastatin (clarithromycin warning).",
    "[11] FDA label for metoprolol (macrolide DDI).",
    "[12] Best clinical practice/expert consensus.",
    "[13] FDA label for amiodarone (pulmonary warning)."
  ]
}}

### References
{references_text}

Always include reference links like the above in your output

Return ONLY a single, valid JSON object. Do NOT include extra brackets or commas. Double-check your formatting.
"""



    headers = {
        "Authorization": "Bearer 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",
        "Content-Type": "application/json"
    }
    groq_payload = {
        "model": "meta-llama/llama-4-maverick-17b-128e-instruct",
        "temperature": 0.0,
        "top_p": 1.0,
        "max_tokens": 8192,
        "stream": False,
        "stop": ["<think>", "<think\>"],
        "messages": [
            {
                "role": "system",
                "content": (
                    "You are a clinical decision support assistant. "
                    "You MUST respond with ONLY the JSON object in the exact format described, "
                    "with no internal thoughts, explanations, or extra text."
                )
            },
            {"role": "user", "content": prompt}
        ]
    }
    groq_response = requests.post(
        "https://api.groq.com/openai/v1/chat/completions",
        headers=headers,
        json=groq_payload
    )
    try:
        groq_json = groq_response.json()
        content  = groq_json["choices"][0]["message"]["content"]
        parsed = robust_json_parse(content)
        if isinstance(parsed, dict) and not parsed.get("error"):
            # Extract and filter only cited references for output
            cited_refs = []
            ref_pattern = re.compile(r"\[(\d+|[^\[\]]+?)\]")
            for cat, vals in parsed.items():
                if cat == "References":
                    continue
                if isinstance(vals, list):
                    for val in vals:
                        for match in ref_pattern.findall(str(val)):
                            key = f"[{match}]"
                            if key not in cited_refs:
                                cited_refs.append(key)
            filtered_refs = filter_references_dict(cited_refs, references_dict)
            parsed["References"] = filtered_refs
            return post_process(parsed)
        return parsed
    except Exception as e:
        return {
            "error": "Failed to parse LLM response",
            "response_status_code": groq_response.status_code,
            "raw_groq_response": groq_response.text,
            "exception": str(e)
        }

    uvicorn.run(app, port=8000)